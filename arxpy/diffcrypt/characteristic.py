"""The Characteristic module provides types of characteristics."""
import collections
import contextlib
import math
import random

from arxpy.bitvector import context
from arxpy.bitvector import core
from arxpy.bitvector import function

from arxpy.diffcrypt import difference
from arxpy.diffcrypt import differential


class Characteristic(collections.abc.MutableMapping):
    """Manage characteristics.

    A characteristic is a sequence of differences obtained from propagating
    an input difference through a bit-vector function. A characteristic
    contains the input and output differences of the function and the
    intermediate differentes at each operation.

    A Characteristic object represent a characteristic as a dictionary-like
    where the keys are the identifiers of the differences and the values
    are the actual values of the differences. A Characteristic object
    can be generated by providing the function, the difference type
    and the input difference.

        >>> from arxpy.bitvector.function import Function
        >>> from arxpy.diffcrypt.difference import XorDiff, DiffVar
        >>> from arxpy.diffcrypt.characteristic import Characteristic
        >>> class MyFunction(Function):
        ...     input_widths = [8, 8, 8]
        ...     output_widths = [8, 8]
        ...     @classmethod
        ...     def eval(cls, x, y, k):
        ...         return (y + k, (y + k) ^ x)
        >>> x, y, k = DiffVar("x", 8), DiffVar("y", 8), DiffVar("k", 8)
        >>> ch = Characteristic(MyFunction, XorDiff, [x, y, k])
        >>> ch
        Characteristic((x, y, k), [(d0, xdp+((k, y), d0)), (d1, d0 ^ x)])
        >>> ch.input_diff
        (x, y, k)
        >>> ch.output_diff
        (d0, d1)
        >>> ch.sequence
        (x, y, k, d0, d1)

    Note that a Characteristic object consider as input difference
    all the arguments of the bit-vector function.

    """

    def __init__(self, func, diff_type, input_diff, prefix="d"):
        """Create a characteristic."""
        assert issubclass(func, function.Function)
        assert issubclass(diff_type, difference.Difference)

        input_diff = core.tuplify(input_diff)

        assert len(input_diff) == len(func.input_widths)
        assert all(isinstance(d, difference.DiffVar) for d in input_diff)
        assert all(not d.name.startswith(prefix) for d in input_diff)

        self.func = func
        self.diff_type = diff_type
        self.input_diff = input_diff
        self.prefix = prefix
        self.output_diff = None
        self.propagations = collections.OrderedDict()

        self._generate()

    def _generate(self):
        """Propagate the input difference through the function."""
        sym_exec = self.func.symbolic_execution(*self.input_diff,
                                                id_prefix=self.prefix)

        self.output_diff = list(sym_exec[0])
        for i, d in enumerate(self.output_diff):
            self.output_diff[i] = difference.DiffVar.from_Variable(d)
        self.output_diff = tuple(self.output_diff)

        self.propagations = collections.OrderedDict()

        for symbol, op in sym_exec[1].items():
            op = op.xreplace({difference.DiffVar.to_Variable(diff_var): diff_var
                             for diff_var in self.propagations.keys()})

            diff_symbol = difference.DiffVar.from_Variable(symbol)
            prop = self.diff_type.propagate(type(op), op.args, diff_symbol)

            assert isinstance(prop, (core.Term, differential.Differential))
            if isinstance(prop, core.Term):
                assert all(not type(d) == core.Variable for d in prop.atoms())

            self.propagations[diff_symbol] = prop

    def __getitem__(self, key):
        return self.propagations.__getitem__(key)

    def __setitem__(self, key, value):
        raise self.propagations.__setitem__(key, value)

    def __delitem__(self, key):
        return self.propagations.__delitem__(key)

    def __len__(self):
        return self.propagations.__len__()

    def __iter__(self):
        return self.propagations.__iter__()

    def __str__(self):
        return '{0}({1}, {2})'.format(type(self).__name__, self.input_diff,
                                      list(self.propagations.items()))

    __repr__ = __str__

    @property
    def sequence(self):
        """The ordered sequence of differences.

        Return the sequence of differences from the input difference
        to the output difference through all the bit-vector operations
        (in order).
        """
        return self.input_diff + tuple(self.propagations.keys())

    def get_weight_function(self):
        """Return the function used to compute the the weights.

        See Differential.weight_function for more information.
        Note that if there are two differentials in the characteristic
        with different weight function, an exception is risen.
        """
        def are_equal(func1, func2, width):
            for i in range(3):
                x = random.randrange(2 ** width)
                if func1(x) != func2(x):
                    return False
            else:
                return True

        f = None
        for var, propagation in self.items():
            if isinstance(propagation, differential.Differential):
                if f is None:
                    f = propagation.weight_function
                else:
                    assert are_equal(f, propagation.weight_function, var.width)

        if f is None:
            return lambda x: x
        else:
            return f

    def get_inverse_weight_function(self):
        """Return the inverse of the weight function."""
        def are_equal(func1, func2, width):
            for i in range(3):
                x = random.randrange(2 ** width)
                if func1(x) != func2(x):
                    return False
            else:
                return True

        inv = None
        for var, propagation in self.items():
            if isinstance(propagation, differential.Differential):
                if inv is None:
                    inv = propagation.inverse_weight_function
                else:
                    assert are_equal(inv, propagation.inverse_weight_function,
                                     var.width)

        if inv is None:
            return lambda x: x
        else:
            return inv

    def empirical_weight(self, differences, constant_conversion=True,
                         theoretical_weight=None):
        """Return the empirical weight for a particular sequence of differences.

        The probability of a characteristic *p* is the probability that
        a random input pair with given input difference follows
        the characteristic.  The weight is the -log(p) and the
        empirical weight is the weight computed by sampling random
        pairs and counting the correct ones.

            >>> from arxpy.bitvector.core import Constant
            >>> from arxpy.bitvector.function import Function
            >>> from arxpy.diffcrypt.difference import XorDiff, DiffVar
            >>> from arxpy.diffcrypt.characteristic import Characteristic
            >>> class MyFunction(Function):
            ...     input_widths = [8, 8, 8]
            ...     output_widths = [8, 8]
            ...     @classmethod
            ...     def eval(cls, x, y, k):
            ...         return (y + k, (y + k) ^ x)
            >>> x, y, k = DiffVar("x", 8), DiffVar("y", 8), DiffVar("k", 8)
            >>> ch = Characteristic(MyFunction, XorDiff, [x, y, k])
            >>> zero = Constant(0, 8)
            >>> ch.empirical_weight([zero for d in ch.sequence])  # doctest:+SKIP
            0

        The theoretical weight can be specified to adjust the
        number of pairs will be sampled.

        Note that math.inf is returned if no correct pairs are found.

        """
        assert len(differences) == len(self.sequence)
        assert all(isinstance(d, core.Constant) for d in differences)

        min_correct_pairs = 3
        if theoretical_weight is not None and theoretical_weight < 32:
            min_pairs = 2 ** theoretical_weight
            max_pairs = 6 * min_pairs
        else:
            min_pairs = 2 ** 10
            max_pairs = 2 ** 20

        input_vars = self.func._symbolic_input()
        sym_exec = self.func.symbolic_execution(*input_vars)

        correct_pairs = 0
        total_pairs = 0

        with contextlib.ExitStack() as stack:
            stack.enter_context(context.Simplification(False))
            if not constant_conversion:
                stack.enter_context(context.Validation(False))

            while correct_pairs < min_correct_pairs or total_pairs < min_pairs:
                if total_pairs > max_pairs:
                    break

                total_pairs += 1

                exec_state1 = {}
                exec_state2 = {}

                for v, diff in zip(input_vars, differences):
                    random_int = random.randrange(2 ** v.width)
                    exec_state1[v] = core.Constant(random_int, v.width)
                    exec_state2[v] = self.diff_type.get_pair_element(
                        exec_state1[v], diff
                    )

                for (identifier, op), diff in zip(sym_exec[1].items(),
                                                  differences[len(input_vars):]):
                    x = op.xreplace(exec_state1)
                    y = op.xreplace(exec_state2)
                    exec_state1[identifier] = x
                    exec_state2[identifier] = y

                    if self.diff_type.get_difference(x, y) != diff:
                        break
                else:
                    correct_pairs += 1

        if correct_pairs == 0:
            return math.inf
        elif total_pairs == correct_pairs:
            return 0
        else:
            return - math.log(correct_pairs / total_pairs, 2)


class CompositeCh(object):
    """Manage composite characteristics.

    A composite characteristic of a composite bit-vector function
    is a pair of characteristics where the first one is a characteristic
    of the inner function and the second one is a characteristic
    of the outer function. In addition, the output difference of the
    inner characteristic is connected to the input difference
    of the outer characteristic.

        >>> from arxpy.bitvector.operation import RotateLeft
        >>> from arxpy.bitvector.function import Function, CompositeFunction
        >>> from arxpy.diffcrypt.difference import XorDiff, DiffVar
        >>> from arxpy.diffcrypt.characteristic import Characteristic, CompositeCh
        >>> class MyInner(Function):
        ...     input_widths = [8]
        ...     output_widths = [8, 8]
        ...     @classmethod
        ...     def eval(cls, k):
        ...         return (k, RotateLeft(k, 1))
        >>> class MyOuter(Function):
        ...     input_widths = [8, 8, 8, 8]
        ...     output_widths = [8, 8]
        ...     @classmethod
        ...     def eval(cls, x, y, k0, k1):
        ...         for ki in [k0, k1]:
        ...             x, y = y + ki, (y + ki) ^ x
        ...         return x, y
        >>> class MyComposite(CompositeFunction):
        ...     input_widths = [8, 8, 8]
        ...     output_widths = [8, 8]
        ...     inner_func = MyInner
        ...     outer_func = MyOuter
        >>> x, y, k = DiffVar("x", 8), DiffVar("y", 8), DiffVar("k", 8)
        >>> ch = CompositeCh(MyComposite, XorDiff, [x, y, k])
        >>> ch.inner_ch
        Characteristic((k,), [(i0, k <<< 1)])
        >>> ch.outer_ch  # doctest:+NORMALIZE_WHITESPACE
        Characteristic((x, y, k, i0), [(o0, xdp+((k, y), o0)), (o1, o0 ^ x),
        (o2, xdp+((i0, o1), o2)), (o3, o0 ^ o2)])

    """

    def __init__(self, func, diff_type, input_diff, inner_prefix="i",
                 outer_prefix="o"):
        """Create a composite characteristic."""
        assert issubclass(func, function.CompositeFunction)

        self.func = func
        self.diff_type = diff_type

        input_diff = core.tuplify(input_diff)
        inner_ninputs = len(func.inner_func.input_widths)
        inner_input_diff = input_diff[-inner_ninputs:]

        self.inner_ch = Characteristic(func.inner_func, diff_type,
                                       inner_input_diff, inner_prefix)

        outer_input_diff = input_diff[:-inner_ninputs] + self.inner_ch.output_diff

        self.outer_ch = Characteristic(func.outer_func, diff_type,
                                       outer_input_diff, outer_prefix)

    def empirical_weight(self, inner_differences, outer_differences,
                         constant_conversion=True, pair_theo_weight=None):
        """Return a pair of empirical weights of the characteristic pair.

        See Characteristic.empirical_weight for more information.

            >>> from arxpy.bitvector.core import Constant
            >>> from arxpy.bitvector.operation import RotateLeft
            >>> from arxpy.bitvector.function import Function, CompositeFunction
            >>> from arxpy.diffcrypt.difference import XorDiff, DiffVar
            >>> from arxpy.diffcrypt.characteristic import Characteristic, CompositeCh
            >>> class MyInner(Function):
            ...     input_widths = [8]
            ...     output_widths = [8, 8]
            ...     @classmethod
            ...     def eval(cls, k):
            ...         return (k, RotateLeft(k, 1))
            >>> class MyOuter(Function):
            ...     input_widths = [8, 8, 8, 8]
            ...     output_widths = [8, 8]
            ...     @classmethod
            ...     def eval(cls, x, y, k0, k1):
            ...         for ki in [k0, k1]:
            ...             x, y = y + ki, (y + ki) ^ x
            ...         return x, y
            >>> class MyComposite(CompositeFunction):
            ...     input_widths = [8, 8, 8]
            ...     output_widths = [8, 8]
            ...     inner_func = MyInner
            ...     outer_func = MyOuter
            >>> x, y, k = DiffVar("x", 8), DiffVar("y", 8), DiffVar("k", 8)
            >>> ch = CompositeCh(MyComposite, XorDiff, [x, y, k])
            >>> zero = Constant(0, 8)
            >>> inner_diffs = [zero for d in ch.inner_ch.sequence]
            >>> outer_diffs = [zero for d in ch.outer_ch.sequence]
            >>> ch.empirical_weight(inner_diffs, outer_diffs)   # doctest:+SKIP
            (0, 0)

        """
        if pair_theo_weight is None:
            pair_theo_weight = [None, None]
        assert len(pair_theo_weight) == 2

        inner_weight = self.inner_ch.empirical_weight(
            inner_differences, constant_conversion, pair_theo_weight[0])
        outer_weight = self.outer_ch.empirical_weight(
            outer_differences, constant_conversion, pair_theo_weight[1])
        return inner_weight, outer_weight
